// Generated by CoffeeScript 1.6.1
(function() {
  var Answer, S, SudokuInput, T, check, draw, grid, piece, pieces, puzzle, px, py, x, y, _i, _j,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  T = require("node-term-ui");

  S = require("sudoku");

  x = 0;

  y = 0;

  grid = {};

  puzzle = {};

  pieces = S.makepuzzle();

  for (px = _i = 0; _i <= 8; px = ++_i) {
    puzzle[px] = {};
    for (py = _j = 0; _j <= 8; py = ++_j) {
      piece = pieces[S.posfor(px, py)];
      puzzle[px][py] = piece !== null ? piece + 1 : false;
    }
  }

  draw = function() {
    return grid[x][y].focus();
  };

  check = function() {
    var addError, cellError, checkNum, cnums, col, colOffset, nums, rnums, row, rowOffset, _k, _l, _m, _n, _o, _results;
    cellError = [];
    addError = function(cell) {
      cell.textColor(T.C.r);
      return cellError.push(cell);
    };
    checkNum = function(nums, x, y) {
      var cell, cur;
      cell = grid[x][y];
      if (cell instanceof Answer) {
        if (cur = nums[cell.val()]) {
          addError(cur);
        }
        return nums[cell.val()] = cell;
      } else if (nums[cell.val()]) {
        return addError(cell);
      } else {
        if (__indexOf.call(cellError, cell) < 0) {
          cell.textColor(T.C.g);
        }
        return nums[cell.val()] = cell;
      }
    };
    for (colOffset = _k = 0; _k <= 2; colOffset = ++_k) {
      for (rowOffset = _l = 0; _l <= 2; rowOffset = ++_l) {
        nums = {};
        for (row = _m = 0; _m <= 2; row = ++_m) {
          for (col = _n = 0; _n <= 2; col = ++_n) {
            checkNum(nums, col + (colOffset * 3), row + (rowOffset * 3));
          }
        }
      }
    }
    _results = [];
    for (row = _o = 0; _o <= 8; row = ++_o) {
      cnums = {};
      rnums = {};
      _results.push((function() {
        var _p, _results1;
        _results1 = [];
        for (col = _p = 0; _p <= 8; col = ++_p) {
          checkNum(cnums, col, row);
          _results1.push(checkNum(rnums, row, col));
        }
        return _results1;
      })());
    }
    return _results;
  };

  SudokuInput = (function(_super) {

    __extends(SudokuInput, _super);

    function SudokuInput(opts) {
      if (opts == null) {
        opts = {};
      }
      opts.borders = false;
      SudokuInput.__super__.constructor.call(this, opts);
      this.x = opts.x;
      this.y = opts.y;
      this.maxLength = 1;
    }

    SudokuInput.prototype.charValidation = function(val) {
      return /[1-9]/.test(val);
    };

    SudokuInput.prototype.onKey_up = function() {
      if (y > 0) {
        y--;
      }
      return draw();
    };

    SudokuInput.prototype.onKey_down = function() {
      if (y < 8) {
        y++;
      }
      return draw();
    };

    SudokuInput.prototype.onKey_left = function() {
      if (x > 0) {
        x--;
      }
      return draw();
    };

    SudokuInput.prototype.onKey_right = function() {
      if (x < 8) {
        x++;
      }
      return draw();
    };

    SudokuInput.prototype.onKey_space = function() {
      this.content = [];
      check();
      this.drawContent();
      return this.drawCursor();
    };

    SudokuInput.prototype.focus = function() {
      x = this.x;
      y = this.y;
      return SudokuInput.__super__.focus.call(this);
    };

    SudokuInput.prototype.key = function() {
      return "" + this.x + "x" + this.y;
    };

    SudokuInput.prototype.val = function() {
      return parseInt(SudokuInput.__super__.val.call(this));
    };

    SudokuInput.prototype.scroll = function() {};

    return SudokuInput;

  })(T.TextInput);

  Answer = (function(_super) {

    __extends(Answer, _super);

    function Answer(opts) {
      Answer.__super__.constructor.call(this, opts);
      this._val = opts.val;
    }

    Answer.prototype.drawContent = function() {
      T.saveFg().fg(T.C.m).pos(this.bounds.x + 1, this.bounds.y + 1).out("" + this._val).restoreFg();
      return this;
    };

    Answer.prototype.val = function() {
      return parseInt(this._val);
    };

    return Answer;

  })(SudokuInput);

  (function(x, y) {
    var g, styler, _k, _l;
    for (x = _k = 0; _k <= 8; x = ++_k) {
      grid[x] = {};
      for (y = _l = 0; _l <= 8; y = ++_l) {
        if (puzzle[x][y]) {
          grid[x][y] = new Answer({
            x: x,
            y: y,
            val: puzzle[x][y]
          });
        } else {
          grid[x][y] = new SudokuInput({
            x: x,
            y: y
          });
          grid[x][y].on("change", check);
        }
      }
    }
    styler = function(r) {
      if (r % 3 === 0) {
        return 3;
      } else {
        return 1;
      }
    };
    g = new T.Grid({
      cols: 9,
      rows: 9,
      cellWidth: 1,
      cellHeight: 1,
      rowStyle: styler,
      colStyle: styler,
      content: grid
    });
    T.clear();
    return g.draw();
  })(x, y);

}).call(this);
